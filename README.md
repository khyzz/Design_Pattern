## 设计模式
#### 1. 迭代器模式
##### 1.1 迭代器模式有什么用
简化操作者使用，操作者遍历整个集合不再需要了解内部具体的数据结构，如数组和链表的遍历肯定是不一样的。
只需要集合内部提供hasNext()和next()的实现，使用者便可以简单遍历整个集合。

##### 1.2 java中的迭代器模式

`Collection`接口继承了`Iterable`接口，并且指定了抽象方法`Iterator<E> iterator();` 因此，所有实现`Collection`的集合类（`List`、`Set`）都需要指定各自的迭代器。

拿`ArrayList`举例，在`ArrayList`中，有一个普通的迭代器`Itr`，`ArrayList`在`Itr`中给出了`hashNext()`与`next()`方法的实现，因此我们无需关系ArrayList底层存储数据的究竟是数组还是链表。当然`ArrayList`还提供了一个功能更加强大的`ListItr`,本质上与`Itr`是一样的。

##### 1.3 小结

迭代器模式较为简单，它将集合对象的遍历功能从集合对象中分离出来，外部使用者可以透明访问集合内部数据，但也因此导致了类个数的增加。

#### 2. 适配器模式

##### 2.1 什么是适配器模式

简单说就是将不同类的功能组合起来，使得调用者无需再去分别调用不同的类，通过适配器类就可以完成全部功能。

##### 2.2 分类

- 类适配器模式：此种情况，一般是适配器类C通过继承类A，实现接口B来完成两种类功能的结合。
- 对象适配器模式：将类A、类B的实例，放在类C中，再C中，调用A或者B中的方法实现功能的结合。

##### 2.3 举例

适配器模式在工作中太常见了，基本上看到`@Resource`或者 `@Autowried`都是使用到了对象适配器模式。此外，如果使用接口作为编译时类型，由于运行时类型是其实现类，只要实现类使用到了其他类的功能，也可以说成是类适配器模式。

#### 3. 模板方法模式

##### 3.1 什么是模板方法模式

简单说就是父类指定了某个方法的流程，但是流程中的方法的具体实现延迟到子类，这个模式可以确保算法的结构保持不变。

##### 3.2 举例

在jdk中，AQS中获取锁和释放锁，其中的`tryAcquire`和 `tryRelease`均有其子类实现，AQS只是规定了获取锁和释放锁的流程，具体怎么获取锁不做规定。

##### 3.3 其他

在jdk8之前，接口是只能定义方法，无法提供实现的，因此模板方法只能使用抽线类，而在jdk8之后，接口可以使用default关键字去实现某个方法，此时实现这个接口的具体类可以不重写这个方法，所以模板方法也可以使用接口实现了。
